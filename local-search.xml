<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2021年终总结</title>
    <link href="/2021/12/31/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2021/12/31/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>2021年是新冠疫情的第二年，在这一年里我依然见到了人性的光辉和伟大。同时在这一年也是我个人面临重大选择的一年，无论对错，只关内心。</p>          </div><h1 id="过去的一年"><a href="#过去的一年" class="headerlink" title="过去的一年"></a>过去的一年</h1><p>过去的一年里经历了很多的事情，在人生的岔路口处我谨慎地做出了我个人认为正确的决策选择，虽然这个过程中出现了比较严重的策略选择失误问题，但是当下的结果还算是可以接受。从2、3月份准备考研，再到6月份放弃考研，捡起Java开始刷题、准备项目和相关知识开始准备找工作，九月份开始大批投简历，九月中收到第一个offer，十月中基本结束秋招。我依然记得在八九月的时候晚上会失眠，第二天依然要早起学习。也记得九月份基本每天都是笔试面试，压力不小，一方面是不知道自己放弃考研临时选择找工作是否能有一个结果，另一方面是自己学校、学历、经历均不占优，对自己也很不自信。</p><p>我很难衡量自己的选择是否正确，也很难对未来的发展进行预测，只能在当下的环境中根据自己的见解做出当下我认为最优/最有利的选择。对于过往我希望能永远把记忆留在心底，但是对我来说最美好的永远是今天和明天。</p><p>此外就是本专业的学习上，依然是难以提起什么兴趣。六七月的时候学院组织我们去峨眉山考察自然地理环境，观测了很多岩石和各种地质现象，但是对于我来说一块石头就是石头，可能它经历了几百年的地质变迁有很高研究价值，但是对于我个人来说这只是一块有研究价值的石头，仅此而已。在我们的社会发展中我们总需要各个方面的人才相对饱和，让社会整体的运行不至于崩溃或者受到掣肘，这也是国内很多大学采用严苛转专业制度的原因，因为我们从社会发展的角度来说只是流水线上生产出的一批产品，我们和桌椅的社会价值根本上都是按照社会的运行意志贡献价值。我在一定程度上认同这种现象存在的必要性和合理性，因为这是社会在欠发达背景下一种自然的走向。但是我个人不是很愿意接受这种所谓的命运的安排，同时我个人也不想做虚拟概念上的卫道士。</p><h1 id="考研or找工作思考"><a href="#考研or找工作思考" class="headerlink" title="考研or找工作思考"></a>考研or找工作思考</h1><ul><li>首先是要梳理一下自己的职业规划和行业要求。比如如果是医、法这类行业对学校/学历有着强要求的专业，完全不用思考，必须考。或者可能有人想在北上广等一线城市落户，那有的城市有积分落户政策，研究生落户比本科生难度低，这种也是可以考虑读研的。再比如有人将来想从事算法类工作，那读研基本上可以说是完全必要的。所以我的看法是：如果研究生学历是达到我们将来目标中不可获取的一环，那读研应该是一种十分必要的手段和阶段。 </li><li>对比不要有时间差。我们常拿自己本科毕业和如果研究生毕业对比，从而认为读研可以有更好的发展，这种对比从社会整体的角度/公司招聘的角度来看是没有问题的，但是落实在个人身上有时间差，<strong>我个人认为</strong>正确的对比应该是本科毕业两三年 和 研究生毕业对比，本科毕业两三年会不会比自己研究生毕业有更多的行业选择（这里只强调互联网行业，考公/进国企/选调不在此类的讨论范围内，因为我个人不是很偏向非互联网行业） </li><li>两者的quit成本。就目前国内的研究生选拔/培养而言，考研无论是选校，还是选导师都有不小的风险。如果遇到比较难接受的导师，可能会对自己的研究生生涯带来比较大的消极影响。那就考虑进了一家坑公司的quit成本和入学之后quit的成本，哪个更高，哪个更能接受。 </li><li>年龄优势。这一点是针对我个人而言的，相当一部分人可能并不具备这一优势。因为我目前还未满20周岁，所以即使我工作两三年后发现研究生学历是我未来发展不可获取的一环，然后去考研读研，年龄可能和毕业后直接读研的同学年龄上是差不多的。</li></ul><h1 id="秋招经历"><a href="#秋招经历" class="headerlink" title="秋招经历"></a>秋招经历</h1><p>我个人从九月开始投递了大量的简历，这里记录一下我印象比较深刻的面试及其结果</p><h2 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h2><p>我清楚的记得9.1我参加了小米的笔试，但是直到十月才被约面，一面的过程很平常，面试官全程一直在笑，问的问题我基本也都答上了。最后先是出了一道算法题，我很快就ac了，面试官笑着说那要不再做一道，我也笑了说行，第二道题也做出来了。最后的反问环节问了一下面试官对我的评价，只记得面试官说感觉我很好。</p><p>印象最深刻的就是二面。当天我预约的晚上7点的面试，等了几分钟面试官进入面试间，说他还在面试前一个候选人让我等一会，这一等就等了半个小时。七点半左右面试官向我发起面试，先是向我道歉了，说了一下对前一位面试同学的评价。没想到这一场竟然面了两个小时，从Java集合源码到Java并发、JVM都有问，有一部分是面试官给了一个场景先写一个简单SQL，再这个场景的基础上不断加条件对表结构进行优化及实现相关功能，这部分让我感觉到面试官很深厚的实战经验。在这个过程我们还交流我个人秋招的经历，都面了哪些公司，手里都有哪些offer，以及交流了怎么学习，如何看待国内的互联网行业的发展，全程都像是一场聊天，我们在交流自己对行业的认识，对技术的了解，这一场面试直接让我把小米的面试好感拉满。</p><p>非常感谢二面面试官给的机会，以及给到我个人的尊重。在面试过程中有一些话其实他是没有义务跟我讲的，但是能这么无私的分享经验，给我指导我真的很感谢他，希望他在之后的职业生涯中一帆风顺，生活快乐。</p><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p>百度我是参与了Java后端开发的笔试，但是因为这个方向太卷了以及自己太菜了，笔试成绩没过关。之后百度发邮件问我是否愿意调剂去安卓开发，当时的我还没有满意的offer，当时是马上表示愿意了，之后就沉寂了十多天。有一天突然收到百度发的面试邀约，很紧张也很兴奋。听说百度是一天三面，哪面停止就是哪面挂了。</p><p>一面的面试官是一个很年轻的男生，看起来也有点腼腆，因为我是做的Java方向，之前没学过安卓开发，面试官开始以为是系统故障安排错面试了，之后我解释了一下，全程面试都是关于Java的一些比较简单的问题，面试官评价不错，顺利二面。</p><p>二面的面试官稍微严肃一些，也以为系统出错安排错面试。在面试过程中我感觉有的问题回答的面试官不是很满意，心里有种要凉凉的感觉，但是还比较幸运，面试官说认为我学习Java还比较扎实，加上我也有向安卓这方面转的想法，继续安排我三面。</p><p>三面面试官口音一听就是北京人，依然以为系统出错安排错面试。在面试过程中也比较尴尬，面试官问了几个问题后就不知道问什么了，于是问了几个场景设计题，最后我反问评价时，面试官说建议我再刷刷算法，继续面后端，听到这就感觉要凉。后面果然感谢信了，但是也很感谢百度，给了我面试的机会，让我对自己更自信了一些，也更明确自己的发展方向了。</p><h2 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h2><p>滴滴今年因为被审查的原因没有正式的校招，只有部门直推，申请的比较晚。</p><p>一面问的很跳脱，不像其他面试问一些很常规的问题。我个人介绍完之后面试官就问我为什么不走不专业，也问了我有没有考研。我说没有， 他问我为什么，我回答完之后他说感觉我挺有意思的，听上去感觉挺有想法的。然后就问我都是怎么学习的，都看过什么书，我从书柜上抽出来我看过的书，之后基本全程被问图论，直到完全答不出来的。这场面试感觉对个人知识的连贯性要求很高，不止要知道一点更要把知识串起来，能感受到面试官基本功很深。最后评价的时候面试官说能感受到我不是瞎学，是有自己的计划，能耐下心学知识的人，感觉还不错，当时还很开心。</p><p>二面就直接痛苦面具了，先是问RPC项目，问了各种IO，这部分我可能说了十分钟。答完面试官就问我知不知道缓存，我说知道，心想这应该就是要问Redis了，结果面试官直接说那你现场给我写一个缓存吧，就是在并发场景长想缓存都可能有哪些功能，实现一个可以直接交付给别人使用的工具类，我一下子就懵了。这场面试暴露了我一个很严重的面试问题，在没有思考的情况下想先去做，出了问题再补，这其实给面试官留下了很不好的印象，比较紧张的情况下频频出错，还没面完就知道肯定挂了，最后面试官说让我可以参考一下guava cache的设计。面完不到五分钟就收到感谢信了。</p><h2 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h2><p>美团是我面试的第一个大厂，一开始很紧张，但是一面面试官很亲和，也是第一个在面试过程中主动介绍自己的名字、所在部门及业务的。在这面试中已经记不清具体细节了，只记得面试的小哥哥人很好，也很尊重人。</p><p>二面面试官看着就像是个大佬，上来先做题，牛客的做题面板有问题，我这边一直显示红色波浪线报错我也一直以为是我写的有问题，不停的修修改改写了二十分钟，实在撑不住了就问面试官我这样写是不是有问题，他说他那边显示没问题啊让我运行一下试试，运行之后发现虽然有红色波浪线实现没有方法，但是运行是没问题的。面试过程中也问的很全面，问了很多方面的知识，有些地方回答的不太好。最后反问的时候想请面试官评价一下我，他说公司有规定不能说，只能从个人主观角度评价一下，感觉我对知识的学习无论是深度上还是广度上都足够了，但是感觉实战经验不足，对于一些具体业务场景上的实现和问题排查上了解不足，后面还要再评估一下。</p><p>二面完等了一个多星期都没消息就给校招组发邮件，挂了。美团是我非常想去的一家公司，被挂还是有点伤心的。</p><h2 id="携程"><a href="#携程" class="headerlink" title="携程"></a>携程</h2><p>携程一面的时候至少一半的时间被怼项目，关于项目的实现问的非常细，后面问了几个比较深的问题让我都有点自闭了。</p><p>携程二面的的面试官长得好像我一个朋友，哈哈哈哈。这一面也算是比较常规的面试，没有太特别的印象。顺利hr面，顺利offer。</p><h2 id="转转"><a href="#转转" class="headerlink" title="转转"></a>转转</h2><p>之所以对这家公司面试印象很深是因为前后对比反差有点大。</p><p>转转一面面试官是我面试过程第一个对方长什么样的面试。</p><p>转转二面体验也很好，是一个女生面试官。在这次面试过程中被问了好几个场景设计题，但是难度其实都不是很难，我在思考的时候面试官还说让我不要紧张，引导了一点，最后说我的想法和他们具体的设计实现比较接近了。此外，在面试过程中面试官突然问我，认为自己最大的优势是什么。我说我相比于身边的一些同学可能更知道自己想要什么，并会付出尽可能多的努力让我的目标实现。她说她认为我最大的优势没有说出来，她认为我最大的优势就是分析和表达能力很强。第一次在面试过程中被面试官夸还是很高兴的。</p><p>转转hr面的时候体验也还不错，我说我对转转印象很好，了解过转转这家公司。hr就问我那都了解到什么，我从转转公司是怎么成立的，主要在做什么市场，怎么和当下政策结合起来做业务，基于什么样的数据判断出我比较看好转转未来的发展。我说完之后hr问我有看过这方面的研究吗还是自己的认知，我说我是基于我了解的数据和事实，加上自己的认知。hr就我除了程序员还有没考虑过其他职业，我不是很明白她是什么意思，最后她说感觉我除了适合当一名程序员，还可以去考虑考虑当PM，因为我本身对技术有了解，还能对市场发展有学习和了解的兴趣，还说希望能在公司早日见到我和我成为同事，当时还是挺开心的。</p><p>9月底收到邮件说我所有面试都已经通过，等待进入offer沟通环节，当时还很高兴。11月底收到邮件说我面试没有通过，而且据我了解我这种情况在今年不少见。</p><h1 id="加密货币"><a href="#加密货币" class="headerlink" title="加密货币"></a>加密货币</h1><p>这一年我正式接触到加密货币，我发现这个圈子和计算机圈子有着一定的相似性，一方面是行业内从业人员背景复杂，原先从事各行各业的都有。其次就是这个圈子信息更新迭代快，需要个人有着比较强的自主学习能力和信息收集能力。</p><p>在我们的主流媒体宣传中，加密货币是一场骗局，是一场巨大的泡沫。我并不否认这个市场存在着巨大的泡沫，但是我同样也看到在这个圈子中真的有人是在致力于推动加密货币科技的发展，真的热爱这个事业并坚信行业的发展前景。其实像我之前也不是很了解，很片面、偏激地看待这个行业。但是直到我直到BTC、ETH在GitHub上有着开源项目、在圈子内已经形成类似银行一样的借贷中心和金融服务、在链上数据是可见的，可以通过链来实现世俗价值的交换，我的观点发生了一些改变，我开始拥抱这个行业，但是目前还是一个学龄前儿童。</p><p>在这个行业内有着大量真真假假的信息，甄别信息的前提是对行业和运行规则充分了解。过去一年先是动物币（Doge、Shib等）的狂欢，在这场狂欢中马斯克以一己之力托起了Shib的价格，让一批holder持有的财富急剧增长。然后涌现了Defi、Gamefi、Socialfi等等，我在今年错过了很多潮流，因为自己缺失了主动学习的态度和兴趣，Messari的年度报告也拖后了很长时间没看。在明年我要更加努力的学习这个行业的知识，主动获取，主动出击。</p><h1 id="展望2022"><a href="#展望2022" class="headerlink" title="展望2022"></a>展望2022</h1><ul><li>参加春招，争取可以拿到一线大厂的工作offer</li><li>开启一场毕业旅行</li><li>学习MIT6.824，入门分布式</li><li>学习DDIA</li><li>继续刷leetcode</li><li>扩展一个兴趣爱好</li><li>开始学做饭</li><li>学习英语</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>2021</tag>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty学习</title>
    <link href="/2021/12/31/Netty%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/12/31/Netty%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><p><img src="....%5Cthemes%5Cfluid%5Csource%5Cimg%5Cimage-20211231172522178.png"></p><p>ByteBuf根据不同的衡量标准可以分成不同类型：</p><ul><li>是否池化：基于对象池的ByteBuf、普通ByteBuf</li><li>内存分配：堆内存ByteBuf、直接内存ByteBuf</li></ul><h3 id="堆内存ByteBuf"><a href="#堆内存ByteBuf" class="headerlink" title="堆内存ByteBuf"></a>堆内存ByteBuf</h3><p>在堆内存中创建和回收速度较快，可以由JVM自动回收。但是在面对Socket的I/O通信中，需要额外做一次内存拷贝，将堆内存中的数据拷贝到堆外临时缓冲区中，再写入SocketChannel中。</p><h3 id="直接内存ByteBuf"><a href="#直接内存ByteBuf" class="headerlink" title="直接内存ByteBuf"></a>直接内存ByteBuf</h3><p>直接将数据存储在堆外的临时缓冲区中。创建和回收时间较长，此外需要注意垃圾回收。直接内存和堆内存相比Socket的I/O通信效率要更高，因为减少了一次拷贝。默认情况下创建的ByteBuf就是直接内存ByteBuf。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(ByteBuf buf)</span> </span>&#123;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder()<br>        .append(<span class="hljs-string">&quot;readerIndex:&quot;</span>).append(buf.readerIndex() + <span class="hljs-string">&quot; &quot;</span>)<br>        .append(<span class="hljs-string">&quot;writerIndex:&quot;</span>).append(buf.writerIndex() + <span class="hljs-string">&quot; &quot;</span>)<br>        .append(<span class="hljs-string">&quot;capacity: &quot;</span>).append(buf.capacity() + <span class="hljs-string">&quot; &quot;</span>)<br>        .append(<span class="hljs-string">&quot;maxCapacity: &quot;</span>).append(buf.maxCapacity() + <span class="hljs-string">&quot; &quot;</span>)<br>        .append(StringUtil.NEWLINE);<br>    io.netty.buffer.ByteBufUtil.appendPrettyHexDump(sb, buf);<br>    System.out.println(sb.toString());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ProtoBuf入门</title>
    <link href="/2021/12/29/probuf%E5%85%A5%E9%97%A8/"/>
    <url>/2021/12/29/probuf%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、为什么使用ProtoBuf"><a href="#一、为什么使用ProtoBuf" class="headerlink" title="一、为什么使用ProtoBuf"></a>一、为什么使用ProtoBuf</h1><ul><li>ProtoBuf是一种序列化技术，在现代网络通信中无法直接在网络中传输Java中的对象，而是要将其进行序列化。</li><li>与Java原生的Serialization相比，ProtoBuf本身是跨语言（支持C++、Python、Go、Java等多门语言）、与平台无关的序列化方式，而Serialization无法跨语言是其一大弊端。</li><li>与XML相比，ProtoBuf的优点是序列化后的码流小，传输效率高。在分布式系统中之所以把整体的单机服务做切分就是为了降低单台机器所承担的压力提高响应效率，而RPC与本地调用的一大区别就是有网络的参与，所以RPC中的一个重点关注的问题就是在不稳定的网络中如何确保信息的安全、可靠、高效。</li></ul><h1 id="二、ProtoBuf的使用"><a href="#二、ProtoBuf的使用" class="headerlink" title="二、ProtoBuf的使用"></a>二、ProtoBuf的使用</h1><p>这里直接引用 <a href="https://developers.google.com/protocol-buffers/docs/javatutorial">ProtoBuf官方文档</a> 中的叙述：</p><blockquote><ul><li>Define message formats in a <code>.proto</code> file.</li><li>Use the protocol buffer compiler.</li><li>Use the Java protocol buffer API to write and read messages.</li></ul></blockquote><h2 id="1-在-proto文件中定义消息格式"><a href="#1-在-proto文件中定义消息格式" class="headerlink" title="1. 在.proto文件中定义消息格式"></a>1. 在.proto文件中定义消息格式</h2><p>创建一个 <code>.proto</code> 文件，在<code>.proto</code>文件中使用<code>message</code>定义希望进行序列化的数据结构，每个<code>message</code>中包含了字段及其类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">syntax = <span class="hljs-string">&quot;proto2&quot;</span>;<br><br><span class="hljs-keyword">package</span> tutorial;<br><br>option java_multiple_files = <span class="hljs-keyword">true</span>;<br>option java_package = <span class="hljs-string">&quot;com.example.tutorial.protos&quot;</span>;<br>option java_outer_classname = <span class="hljs-string">&quot;AddressBookProtos&quot;</span>;<br><br>message Person &#123;<br>  optional string name = <span class="hljs-number">1</span>;<br>  optional int32 id = <span class="hljs-number">2</span>;<br>  optional string email = <span class="hljs-number">3</span>;<br><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PhoneType</span> </span>&#123;<br>    MOBILE = <span class="hljs-number">0</span>;<br>    HOME = <span class="hljs-number">1</span>;<br>    WORK = <span class="hljs-number">2</span>;<br>  &#125;<br><br>  message PhoneNumber &#123;<br>    optional string number = <span class="hljs-number">1</span>;<br>    optional PhoneType type = <span class="hljs-number">2</span> [<span class="hljs-keyword">default</span> = HOME];<br>  &#125;<br><br>  repeated PhoneNumber phones = <span class="hljs-number">4</span>;<br>&#125;<br><br>message AddressBook &#123;<br>  repeated Person people = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>java_multiple_files = true</code> 可以让每个生成类单独生成一个<code>.java</code>文件，而不是嵌套在一个文件中。<code>java_package = &quot;com.example.tutorial.protos&quot;</code> 声明生成文件的包地址。 <code>java_outer_classname = &quot;AddressBookProtos&quot;</code> 生成文件名。</p><p>上面的定义中声明了两个类 <code>Person</code>、 <code>Message</code>，在<code>Person</code>类中又定义了一个 <code>PhoneNumber</code> 类 。<code>string</code>、<code>int32</code> 都是字段的类型。</p><p>每个字段都必须被下列中的一个修饰符所注释：</p><ul><li><code>option</code>：字段可能被设置也可能不被设置，如果不设置会直接使用字段类型所对应的默认值。</li><li><code>repeated</code>：字段是可以重复多次的（可以重复0次）。在compiler编译之后会变成Java的List集合。</li><li><code>required</code>：字段的值必须进行设置，如果不设置就会被视为“未初始化”。尝试构建一个未初始化的message会抛出<code>RuntimeExceptiona</code>。解析一个未初始化的message会抛出<code>IOException</code>。</li></ul><div class="note note-danger">            <p><strong>Required Is Forever</strong> You should be very careful about marking fields as <code>required</code>. If at some point you wish to stop writing or sending a required field, it will be problematic to change the field to an optional field – old readers will consider messages without this field to be incomplete and may reject or drop them unintentionally. You should consider writing application-specific custom validation routines for your buffers instead. Within Google, <code>required</code> fields are strongly disfavored; most messages defined in proto2 syntax use <code>optional</code> and <code>repeated</code> only. (Proto3 does not support <code>required</code> fields at all.)</p>          </div><h2 id="2-使用-protocol-buffer-编译器"><a href="#2-使用-protocol-buffer-编译器" class="headerlink" title="2.使用 protocol buffer 编译器"></a>2.使用 protocol buffer 编译器</h2><ol><li>首先是要下载和配置编译器，这部分可以看官网文档。ProtoBuf是跨语言的，无论什么语言在定义时都是先定义<code>.proto</code>文件，只是不同语言对应的编译器不同</li><li>在cmd中运行complier，命令格式 <code>protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto</code> </li></ol><h2 id="3-使用protocol-buffer-API"><a href="#3-使用protocol-buffer-API" class="headerlink" title="3.使用protocol buffer API"></a>3.使用protocol buffer API</h2><p>protocol buffer采用的是Builder模式，通过Builder创建对象以及对属性进行设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">SubscribeRespProto.SubscribeResp.Builder builder = SubscribeRespProto.SubscribeResp.newBuilder();<br>builder.setSubReqID(subReqID);<br>builder.setRespCode(<span class="hljs-number">0</span>);<br>builder.setDesc(<span class="hljs-string">&quot;Netty book order succeed, 3 days later, sent to the designated address&quot;</span>);<br><span class="hljs-keyword">return</span> builder.build();<br></code></pre></td></tr></table></figure><p>序列化与反序列化：</p><ul><li><code>byte[] toByteArray();</code>: 将message序列化为byte数组返回</li><li><code>static Person parseFrom(byte[] data);</code>:从给的一个byte数组中解析出Person类</li><li><code>void writeTo(OutputStream output);</code>: 序列化message并写到输入流中</li><li><code>static Person parseFrom(InputStream input);</code>: 从一个输入流中读取和解析</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>ProtoBuf</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
